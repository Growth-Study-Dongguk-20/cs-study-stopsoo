## CS Study - Section023 디자인 패턴
### ✏️ Study
#### 💡 디자인 패턴(Design Pattern)의 개요
- 의미
  - 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제.
- 특징
  - 에릭 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vlissides)의 GoF(Gang of Four)가 처음으로 구체화 및 체계화.
  - 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성됨.
  - 개발 과정 중 문제가 발생하면, 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적임.
  - 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화함.
  - GoF의 디자인 패턴은 수많은 디자인 패턴들 중 가장 일반적인 사례에 적용될 수 있는 패턴들을 분류하여 정리함으로써, 지금까지도 소프트웨어 공학이나 현업에서 가장 많이 사용되는 디자인 패턴임.
  - 5개의 `생성 패턴`, 7개의 `구조 패턴`, 11개의 `행위 패턴`으로 구성됨.
##### 🔖 아키텍처 패턴 vs 디자인 패턴
- 아키텍처 패턴이 디자인 패턴보다 상위 수준의 설계에 사용됨.
- 아키텍처 패턴은 전체 시스템의 구조를 설계하기 위한 참조 모델이라면, 디자인 패턴은 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델임.
- 몇몇 디자인 패턴은 특정 아키텍처 패턴을 구현하는데 유용하게 사용됨.
<br>

#### 💡 디자인 패턴 사용의 장/단점 
- 범용적인 코딩 스타일로 인해 구조 파악이 용이.
- 객체지향 설계 및 구현의 생산성을 높이는 데 적합.
- 검증된 구조의 재사용 ➡️ 개발 시간과 비용 절약.
- 초기 투자 비용이 부담될 수 있음. ➡️ 요구사항을 직관적으로 구현하는 게 아니라, 디자인 패턴에 맞게 구현해야 하기 때문.
- 개발자 간의 원활한 의사소통 가능.
- 설계 변경 요청에 대한 유연한 대처 가능.
<br>

#### 💡 생성 패턴(Creational Pattern)
- **객체의 생성과 관련**된 패턴.
- 객체의 생성과 참조과정을 `캡슐화`. ➡️ 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 함. **유연성🆙**<br>

|  패턴 이름  |  특징  |
|:---------:|--------|
| **추상 팩토리<br>(Abstract Factory)** | - 인터페이스를 통해 서로 연관/의존하는 객체들의 그룹으로 생성하여 추상적으로 표현.<br>- 연관된 서브 클래스들을 묶어 한 번에 교체하는 것이 가능. |
| **빌더<br>(Builder)** | - 인스턴스를 건축하듯이 조합하여 객체를 생성.<br>- 객체의 생성 과정과 표현 방법을 분리. ➡️ 동일한 객체 생성에서도 서로 다른 결과 도출 가능. |
| **팩토리 메소드<br>(Factory Method)** | - `가상 생성자(Virtual Constructor)`라고도 함.<br>- 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화.<br>- 상위 클래스에서는 인터페이스만 정의하고, 실제 객체 생성은 서브 클래스가 담당함. |
| **프로토타입<br>(Prototype)**| - 원본 객체를 `복제`하는 방법으로 객체를 생성. <br>- 비용이 큰 경우 주로 이용. |
| **싱글톤<br>(Singleton)** | - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 ❌<br>- 클래스 내에서 인스턴스가 하나 뿐임을 보장.<br>- 불필요한 메모리 낭비 최소화 가능.|
<br>

#### 💡 구조 패턴(Structural Pattern)
- 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴.
- 구조가 복잡한 시스템을 개발하기 쉽게 도와줌.<br>

|  패턴 이름  |  특징  |
|:---------:|--------|
| **어댑터<br>(Adapter)** | - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해줌.<br>- 기존의 클래스를 이용하고 싶지만, 인터페이스가 일치하지 않을 때 이용. |
| **브리지<br>(Bridge)** | - 구현부에서 추상층을 분리, 서로가 독립적으로 확장할 수 있도록 구성.<br>- 기능과 구현을 두 개의 별도 클래스로 구현. |
| **컴포지트<br>(Composite)** | - 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용.<br>- 복합 객체 안에 복합 객체가 포함되는 구조 구현 가능. |
| **데코레이터<br>(Decorator)** | - 객체 간의 결합을 통해 능동적으로 기능들을 확장 할 수 있음.<br>- 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현. |
| **퍼싸드<br>(Facade)** | - 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성. ➡️ 서브 클래스들의 기능을 더 간편하게 사용 가능.<br>- 서브 클래스들 사이의 통합 인터페이스를 제공하는 `Wrapper 객체`가 필요. |
| **플라이웨이트<br>(Flyweight)** | - 인스턴스를 가능한 한 공유해서 사용함으로써 메모리를 절약.<br>- 다수의 유사 객체 생성 및 조작 시 유용. |
| **프록시<br>(Proxy)** | - 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행.<br>- 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 이용. |
<br>

#### 💡 행위 패턴(Behavioral Pattern)
- 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴.
- 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화할 수 있도록 도움.<br>

|  패턴 이름  |  특징  |
|:---------:|--------|
| **책임 연쇄<br>(Chain of Responsibility)** | - 요청을 처리할 수 있는 객체가 둘 이상 존재하여, 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴.<br>- 요청이 해결될 때까지 고리를 따라 책임이 넘어감. |
| **커맨드<br>(Command)** | - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록, 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴.<br>- 요청에 사용되는 각종 명령어들을 `추상 클래스`와 `구체 클래스`로 분리하여 단순화. |
| **인터프리터<br>(Interpreter)** | - 언어에 문법 표현을 정의.<br>- SQL이나 통신 프로토콜 개발 시 사용. |
| **반복자<br>(Iterator)** | - 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 함.<br>- 내부 표현 방법의 노출 없이 순차적인 접근 가능. |
| **중재자<br>(Mediator)** | - 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴.<br>- 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음.<br>- 객체 간의 통제와 지시의 역할을 수행. |
| **메멘토<br>(Memento)** | - 특정 시점에서의 객체 내부 상태를 객체화함으로써, 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공.<br>- `Ctrl + Z` |
| **옵저버<br>(Observer)** | - 한 객체의 상태가 변하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴.<br>- 분산된 시스템 간에 이벤트를 생성/발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용. |
| **상태<br>(State)** | - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용.<br>- 객체 상태를 캡슐화하고 이를 참조. |
| **전략<br>(Strategy)** | - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의. |
| **템플릿 메소드<br>(Template Method)** | - 상위 클래스에서 골격을 정의, 하위 클래스에서 세부 처리를 구체화하는 구조. |
| **방문자<br>(Visitor)** | - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성.<br>- 분리된 처리 기능은 각 클래스를 방문해 수행. |
