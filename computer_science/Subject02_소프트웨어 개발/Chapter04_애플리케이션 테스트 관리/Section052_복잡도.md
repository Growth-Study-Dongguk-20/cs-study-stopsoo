## CS Study - Section052 복잡도
### ✏️ Study
#### 💡 복잡도의 개요
- 의미
  - 시스템이나 시스템 구성 요소 또는 소프트웨어의 복잡한 정도.
- 특징
  - 시스템 또는 소프트웨어를 어느 정도의 수준까지 테스트해야 하는지, 개발하는데 어느 정도의 자원이 소요되는지 예측하는데 사용됨.
  - 주요 복잡도 측정 방법으로 LOC(Line Of Code), 순환 복잡도(Cyclomatic Complexity) 등이 존재.
<br>

#### 💡 시간 복잡도
- 의미
  - 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화한 것.
- 특징
  - 시간 복잡도가 낮을수록 알고리즘의 실행시간이 짧고, 높을수록 실행시간이 길어짐.
  - 시간 복잡도는 알고리즘의 실행시간이 하드웨어적 성능이나 프로그래밍 언어의 종류에 따라 달라지기 때문에 시간이 아닌 명령어의 실행 횟수를 표기함.
##### 🔖 점근 표기법의 종류
- 빅오 표기법 : 알고리즘의 실행 시간이 `최악`일 때를 표기하는 방법.
- 빅세타 표기법 : 알고리즘의 실행 시간이 `평균`일 때를 표기하는 방법.
- 빅오메가 표기법 : 알고리즘의 실행 시간이 `최상`일 때를 표기하는 방법.
<br>

#### 💡 빅오 표기법(Big-O Notation)
- 알고리즘의 실행 시간이 최악일 때를 표기하는 방법,
- 빅오메가 표기법, 빅세타 표기법에 비해 주로 사용됨.<br>

| 표기법          | 특징 |
|:-------------:|-----|
| $O(1)$ | - 입력값에 관계 없이 일정하게 문제 해결에 하나의 단계만을 거침.<br>- 스택의 삽입(Push), 삭제(Pop) |
| $O(logn)$ | - 문제 해결에 필요한 단계가 입력값 또는 조건에 의해 감소.<br>- 이진 트리(Binary Tree), 이진 검색(Binary Search) |
| $O(n)$ | - 문제 해결에 필요한 단계가 입력값과 1:1의 관계를 가짐.<br>- for문 |
| $O(nlogn)$ | - 문제 해결에 필요한 단계가 $nlogn$ 번만큼 수행됨.<br>- 힙 정렬(Heap Sort), 2-Way 합병 정렬(Merge Sort) |
| $O(n^2)$ | - 문제 해결에 필요한 단계가 $n^2$ 만큼 수행됨.<br>- 삽입 정렬(Insertion Sort), 쉘 정렬(Shell Sort), 선택 정렬(Selection Sort), 버블 정렬(Bubble Sort), 퀵 정렬(Quick Sort) |
| $O(2^n)$ | - 문제 해결에 필요한 단계가 $2^n$ 만큼 수행됨.<br>- 피보나치 수열(Fibonacci Sequence) |
<br>

#### 💡 순환 복잡도
- 한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어의 척도.
- 맥케이브 순환도 or 맥케이브 복잡도 메트릭
- 순환 복잡도 구하는 방법
  - 순환 복잡도 = 제어 흐름도의 영역 수 ➡️ 영역 수 계산
  - V(G) = E - N + 2 (E: 화살표 수, N: 노드 수)
